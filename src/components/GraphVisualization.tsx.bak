'use client';

import { useEffect, useState, useCallback } from 'react';
import ReactFlow, {
  Node,
  Edge,
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  MarkerType,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { RefreshCw } from 'lucide-react';

export default function GraphVisualization() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);

  const loadGraphData = useCallback(async () => {
    setLoading(true);
    try {
      const [customers, locations, sublocations, venues, slvRelations] = await Promise.all([
        fetch('/api/customers').then(r => r.json()),
        fetch('/api/locations').then(r => r.json()),
        fetch('/api/sublocations').then(r => r.json()),
        fetch('/api/venues').then(r => r.json()),
        fetch('/api/sublocation-venues').then(r => r.json()),
      ]);

      const newNodes: Node[] = [];
      const newEdges: Edge[] = [];

      let yOffset = 0;
      const xSpacing = 300;
      const ySpacing = 150;

      // Create customer nodes
      customers.forEach((customer: any, cIndex: number) => {
        newNodes.push({
          id: `customer-${customer._id}`,
          type: 'default',
          data: { 
            label: (
              <div className="text-center">
                <div className="font-bold text-blue-700">{customer.name}</div>
                <div className="text-xs text-gray-600">{customer.email}</div>
              </div>
            )
          },
          position: { x: 0, y: cIndex * 700 },
          style: { 
            background: '#DBEAFE', 
            border: '2px solid #3B82F6',
            borderRadius: '8px',
            padding: '10px',
            width: 220,
          },
        });

        // Get locations for this customer
        const customerLocations = locations.filter((l: any) => l.customerId === customer._id);
        
        customerLocations.forEach((location: any, lIndex: number) => {
          const locationY = cIndex * 700 + lIndex * 300;
          
          // Calculate total allocated capacity from sublocations
          const locationSublocations = sublocations.filter((sl: any) => sl.locationId === location._id);
          const totalAllocated = locationSublocations.reduce((sum: number, sl: any) => sum + (sl.allocatedCapacity || 0), 0);
          const remainingCapacity = location.totalCapacity ? location.totalCapacity - totalAllocated : null;
          
          newNodes.push({
            id: `location-${location._id}`,
            type: 'default',
            data: { 
              label: (
                <div className="text-center">
                  <div className="font-bold text-green-700">{location.name}</div>
                  <div className="text-xs text-gray-600">{location.city}</div>
                  {location.totalCapacity && (
                    <div className="mt-1 space-y-0.5">
                      <div className="text-xs font-semibold text-green-800">
                        Total: {location.totalCapacity}
                      </div>
                      <div className="text-xs text-gray-600">
                        Allocated: {totalAllocated}
                      </div>
                      {remainingCapacity !== null && (
                        <div className={`text-xs font-medium ${remainingCapacity >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                          Available: {remainingCapacity}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )
            },
            position: { x: xSpacing, y: locationY },
            style: { 
              background: '#D1FAE5', 
              border: '2px solid #10B981',
              borderRadius: '8px',
              padding: '12px',
              width: 200,
            },
          });

          // Edge from customer to location
          newEdges.push({
            id: `e-${customer._id}-${location._id}`,
            source: `customer-${customer._id}`,
            target: `location-${location._id}`,
            type: 'smoothstep',
            animated: false,
            markerEnd: { type: MarkerType.ArrowClosed },
            style: { stroke: '#10B981' },
          });

          // Get sublocations for this location
          
          locationSublocations.forEach((sublocation: any, slIndex: number) => {
            const sublocationY = locationY - 120 + slIndex * 140;
            
            // Calculate total venue capacity for this sublocation
            const sublocationVenueRels = slvRelations.filter((rel: any) => rel.subLocationId === sublocation._id);
            const sublocationVenues = sublocationVenueRels
              .map((rel: any) => venues.find((v: any) => v._id === rel.venueId))
              .filter(Boolean);
            const totalVenueCapacity = sublocationVenues.reduce((sum: number, v: any) => sum + (v.capacity || 0), 0);
            
            newNodes.push({
              id: `sublocation-${sublocation._id}`,
              type: 'default',
              data: { 
                label: (
                  <div className="text-center">
                    <div className="font-bold text-orange-700">{sublocation.label}</div>
                    {sublocation.allocatedCapacity !== undefined && (
                      <div className="mt-1 space-y-0.5">
                        <div className="text-xs font-semibold text-orange-800">
                          Allocated: {sublocation.allocatedCapacity}
                        </div>
                        <div className="text-xs text-gray-600">
                          Venues: {totalVenueCapacity}
                        </div>
                        {sublocation.allocatedCapacity > 0 && (
                          <div className={`text-xs font-medium ${totalVenueCapacity <= sublocation.allocatedCapacity ? 'text-green-600' : 'text-red-600'}`}>
                            {totalVenueCapacity <= sublocation.allocatedCapacity ? '✓' : '⚠️'} {sublocation.allocatedCapacity - totalVenueCapacity} left
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                )
              },
              position: { x: xSpacing * 2, y: sublocationY },
              style: { 
                background: '#FED7AA', 
                border: '2px solid #F97316',
                borderRadius: '8px',
                padding: '10px',
                width: 160,
              },
            });

            // Edge from location to sublocation
            newEdges.push({
              id: `e-${location._id}-${sublocation._id}`,
              source: `location-${location._id}`,
              target: `sublocation-${sublocation._id}`,
              type: 'smoothstep',
              animated: false,
              markerEnd: { type: MarkerType.ArrowClosed },
              style: { stroke: '#F97316' },
              label: sublocation.allocatedCapacity ? `${sublocation.allocatedCapacity}` : '',
            });

            // Get venues for this sublocation
            
            sublocationVenueRels.forEach((rel: any, vIndex: number) => {
              const venue = venues.find((v: any) => v._id === rel.venueId);
              if (!venue) return;

              const venueId = `venue-${venue._id}`;
              
              // Check if venue node already exists
              if (!newNodes.find(n => n.id === venueId)) {
                const venueY = sublocationY - 60 + vIndex * 100;
                
                newNodes.push({
                  id: venueId,
                  type: 'default',
                  data: { 
                    label: (
                      <div className="text-center">
                        <div className="font-bold text-purple-700 text-sm">{venue.name}</div>
                        <div className="text-xs text-gray-600">{venue.venueType}</div>
                        {venue.capacity !== undefined && (
                          <div className="text-xs font-semibold text-purple-600 mt-1">
                            Cap: {venue.capacity}
                          </div>
                        )}
                      </div>
                    )
                  },
                  position: { x: xSpacing * 3, y: venueY },
                  style: { 
                    background: '#E9D5FF', 
                    border: '2px solid #A855F7',
                    borderRadius: '8px',
                    padding: '8px',
                    width: 130,
                  },
                });
              }

              // Edge from sublocation to venue with capacity label
              newEdges.push({
                id: `e-${sublocation._id}-${venue._id}`,
                source: `sublocation-${sublocation._id}`,
                target: venueId,
                type: 'smoothstep',
                animated: true,
                markerEnd: { type: MarkerType.ArrowClosed },
                style: { stroke: '#A855F7' },
                label: venue.capacity ? `${venue.capacity}` : '',
              });
            });
          });
        });
      });

      setNodes(newNodes);
      setEdges(newEdges);
    } catch (error) {
      console.error('Failed to load graph data:', error);
    } finally {
      setLoading(false);
    }
  }, [setNodes, setEdges]);

  const syncToNeo4j = async () => {
    setSyncing(true);
    try {
      const response = await fetch('/api/graph/sync', { method: 'POST' });
      if (response.ok) {
        alert('Successfully synced to Neo4j!');
      } else {
        alert('Failed to sync to Neo4j. Make sure Neo4j is running.');
      }
    } catch (error) {
      console.error('Sync error:', error);
      alert('Failed to sync to Neo4j. Make sure Neo4j is running.');
    } finally {
      setSyncing(false);
    }
  };

  useEffect(() => {
    loadGraphData();
  }, [loadGraphData]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="text-xl text-gray-600">Loading graph...</div>
      </div>
    );
  }

  return (
    <div className="relative">
      <div className="absolute top-4 right-4 z-10 flex gap-2">
        <button
          onClick={loadGraphData}
          className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 flex items-center gap-2"
        >
          <RefreshCw className="w-4 h-4" />
          Refresh
        </button>
        <button
          onClick={syncToNeo4j}
          disabled={syncing}
          className="px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 disabled:bg-gray-400"
        >
          {syncing ? 'Syncing...' : 'Sync to Neo4j'}
        </button>
      </div>

      <div style={{ height: '800px', width: '100%' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          fitView
          attributionPosition="bottom-left"
        >
          <Background />
          <Controls />
          <MiniMap 
            nodeColor={(node) => {
              if (node.id.startsWith('customer')) return '#3B82F6';
              if (node.id.startsWith('location')) return '#10B981';
              if (node.id.startsWith('sublocation')) return '#F97316';
              return '#A855F7';
            }}
          />
        </ReactFlow>
      </div>

      <div className="mt-4 bg-white rounded-lg p-4 border border-gray-200">
        <h3 className="font-semibold text-gray-800 mb-2">Legend</h3>
        <div className="grid grid-cols-4 gap-4">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-blue-200 border-2 border-blue-500 rounded"></div>
            <span className="text-sm text-gray-700">Customer</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-green-200 border-2 border-green-500 rounded"></div>
            <span className="text-sm text-gray-700">Location</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-orange-200 border-2 border-orange-500 rounded"></div>
            <span className="text-sm text-gray-700">Sub-Location</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-purple-200 border-2 border-purple-500 rounded"></div>
            <span className="text-sm text-gray-700">Venue</span>
          </div>
        </div>
      </div>
    </div>
  );
}
